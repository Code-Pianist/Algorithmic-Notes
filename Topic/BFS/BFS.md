# BFS

## 例题

#### [1565 · 飞行棋 I - LintCode](https://www.lintcode.com/problem/1565/)

```
方法1：
BFS+BFS
外层 BFS 做最短路径
内层 BFS 找连通块
```

```
方法2：两个队列交替
使用 BFS 实现中两个队列交替的方法
将通过掷骰子跳到的点放在下一个队列里
将通过直连到达的点放在当前队列里
这样就不会破坏每个队列为同一层节点的属性
```

```
方法3：SPFA
SPFA = Shortest Path Fast Algorithm
这个算法实际上是基于 BFS 算法的一个拓展
BFS 算法求最短路要求简单图
SPFA 可以解决非简单图的最短路径

问：为什么 BFS 不能解决复杂图？
简单图中：第几层访问到该节点=到达该节点的最短路径
复杂图中：我可能通过三层访问到比通过两层访问到的路径更短

SPFA
SPFA 的解决方式复杂图中访问层级和最短路径不匹配的办法是:
如果我在第三层中发现一个第二层中访问过的节点
但是此时找到的路径更短
就丢回队列——再从这个节点出发往下拓展

SPFA
一个节点是否被扔进队列的判断标准发生变化：
简单图：没有访问过的点就扔进队列
复杂图：如果到达该点的路径变短了就扔进队列

方法4：动态规划(DP)
找最短路径也在动态规划的魔爪范围内
由于规定了跳跃的方向性（从左到右）
可以使用坐标型动态规划自底向上（从右至左）来计算
```

#### 邮局问题 II

https://www.lintcode.com/problem/build-post-office-ii/

在 nxm 的矩阵的空地中找一个位置建立邮局
使得所有房子的格子离邮局的距离之和最短
矩阵中有空地、障碍、房子

```
方法1：枚举邮局位置
for 邮局位置 => O(SPACE)
计算所有点离邮局的距离=计算邮局离所有点的距离 => O(nm)
总体时间复杂度 O(SPACE*n*m)
最坏情况 O(n^2*m^2)
```

[剑指 Offer II 109. 开密码锁 - 力扣（LeetCode）](https://leetcode.cn/problems/zlDJc7/)
